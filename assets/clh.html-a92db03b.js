import{_ as a,V as e,W as p,X as n,a0 as t,Y as o,$ as c,F as l}from"./framework-fd210779.js";const i="/assets/clh-550b9f00.png",u={},d=c(`<h1 id="clh锁" tabindex="-1"><a class="header-anchor" href="#clh锁" aria-hidden="true">#</a> clh锁</h1><p>框架的核心是维护被阻止线程的队列，这些队列在这里仅限于FIFO队列。因此，该框架不支持基于优先级的同步。</p><p>如今，几乎没有争议，同步队列最合适的选择是非阻塞数据结构，这些结构本身不需要使用较低级别的锁构建。其中，有两个主要候选者：Mellor-Crummey和Scott（MCS）锁的变体[9]，以及Craig、Landin和Hagersten（CLH）锁的变体[5][8][10]。从历史上看，CLH锁只用于自旋锁。然而，它们似乎比MCS更适合在同步器框架中使用，因为它们更容易适应处理取消和超时，因此被选为基础。由此产生的设计与原始CLH结构相去甚远，需要解释。</p><p>CLH队列不是很像队列，因为它的排队和排队操作与其作为锁的用途密切相关。这是一个链接队列，通过头部和尾部这两个原子可更新的字段访问，这两个字段最初都指向一个虚拟节点。</p><p>使用原子操作排队新节点，节点：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">do</span> <span class="token punctuation">{</span>
  pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>tail<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个节点的发布状态都保留在前一个节点中。因此，旋转锁的“旋转”看起来像：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>status <span class="token operator">!=</span> <span class="token constant">RELEASED</span><span class="token punctuation">)</span> <span class="token punctuation">;</span> <span class="token comment">// spin</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>旋转后的队列操作只需将头部字段设置为刚刚获得锁的节点：<code>head = node;</code></p><p>CLH锁的优点之一是进队和出队速度快、无锁、无阻塞（即使在争用下，一个线程也总是会赢得插入比赛，因此会取得进展）；检测是否有线程在等待也很快（只需检查头部是否与尾部相同）；释放状态是分散的，避免了一些内存争用。</p><p>在原始版本的CLH锁中，甚至没有连接节点的链接。在自旋锁中，pred变量可以作为本地变量保存。然而，Scott和Scherer[10]表明，通过在节点内显式维护前身字段，CLH锁可以处理超时和其他形式的取消：如果节点的前身取消，节点可以向上滑动以使用上一个节点的状态字段。</p><p>使用CLH队列阻止同步器所需的主要额外修改是为一个节点定位其后续节点提供高效方式。在自旋锁中，节点只需要更改其状态，其继任者下次旋转时会注意到这一点，因此链接是不必要的。但在阻塞同步器中，节点需要显式唤醒（取消停用）其继任者。</p><p><code>AbstractQueuedSynchronizer</code>队列节点包含其后续节点的下一个链接。但是，由于没有使用 <code>compareAndSet</code> 对双链路列表节点进行无锁原子插入的适用技术，因此此链接不是作为插入的一部分进行原子设置的；它只是分配：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>插入后。这反映在所有用法中。下一个链接仅被视为优化路径。如果节点的继承者似乎没有通过下一个字段存在（或似乎被取消），则始终可以从列表的尾部开始，并使用预置字段向后遍历，以准确检查是否真的有一个。</p><p>第二组修改是使用每个节点中保存的状态字段来控制阻塞，而不是旋转。在同步器框架中，排队的线程只有在传递具体子类中定义的<code>tryAcquire</code>方法时才能从获取操作返回；单个“释放”位是不够的。但仍然需要控制，以确保活动线程只有在队列首时才允许调用<code>tryAcquire</code>；在这种情况下，它可能无法获取和（重新）阻止。这不需要每个节点的状态标志，因为可以通过检查当前节点的前身是头部来确定权限。与自旋锁的情况不同，没有足够的内存争用读取头来证明复制。但是，取消状态必须仍然存在于状态字段中。</p><p>队列节点状态字段还用于避免不必要的<code>park</code>和<code>unpark</code>调用。虽然这些方法随着阻塞原语的速度相对较快，但它们在Java和JVM运行时和/或操作系统之间的边界交叉中遇到了可避免的开销。在调用<code>park</code>之前，线程会设置<code>signal me</code>位，然后在调用<code>park</code>之前再次重新检查同步和节点状态。释放线程清除状态。这避免了线程不必要地试图频繁地阻止以获得价值，特别是对于锁类来说，在这些类中，等待下一个符合条件的线程获取锁的时间会加剧其他争用效果。这也避免了要求释放线程来确定其继任者，除非继任者设置了信号位，这反过来又消除了它必须遍历的情况多个节点，以处理一个明显为空的下一个字段，除非与取消一起发生信令。</p><p>也许同步器框架中使用的CLH锁的变体与其他语言中使用的锁之间的主要区别在于，垃圾收集来管理节点的存储回收，从而避免了复杂性和开销。然而，对GC的依赖仍然意味着在肯定永远不会需要链接字段时取消链接字段。这通常可以在排队时完成。否则，未使用的节点仍然可以访问，导致它们无法收集。</p><p>J2SE1.5版本的源代码文档描述了一些进一步的小调优，包括第一次争用时CLH队列所需的初始虚拟节点的惰性初始化。</p><p>省略了这些细节，由此实现基本获取操作的一般形式（仅限独家、不间断、不定时的情况）是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node <span class="token operator">=</span> create and enqueue <span class="token keyword">new</span> node<span class="token punctuation">;</span>
  pred <span class="token operator">=</span> node&#39;s effective predecessor<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>pred is not head node <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred&#39;s signal bit is set<span class="token punctuation">)</span>
      <span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    compareAndSet pred&#39;s signal bit <span class="token keyword">to</span> <span class="token namespace">true</span><span class="token punctuation">;</span>
    pred <span class="token operator">=</span> node&#39;s effective predecessor<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  head <span class="token operator">=</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>释放操作是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> head node&#39;s signal bit is set<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  compareAndSet head&#39;s signal bit <span class="token keyword">to</span> <span class="token namespace">false</span><span class="token punctuation">;</span>
  unpark head&#39;s successor<span class="token punctuation">,</span> <span class="token keyword">if</span> one exists
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，主获取循环的迭代次数取决于<code>tryAcquire</code>的性质。否则，在没有取消的情况下，获取和释放的每个组件都是恒定时间O（1）操作，跨线程摊销，忽略了<code>park</code>内发生的任何操作系统线程调度。</p><p>取消支持主要需要检查每次从收购循环中的<code>park</code>返回时是否有中断或超时。因超时或中断而取消的线程设置其节点状态并取消停放其后续线程，以便它可以重置链接。在取消时，确定前身和继任者以及重置状态可能包括O（n）遍历（其中n是队列的长度）。由于线程永远不会再次阻止已取消的操作，链接和状态字段往往会快速恢复稳定。</p><h2 id="节点信息" tabindex="-1"><a class="header-anchor" href="#节点信息" aria-hidden="true">#</a> 节点信息</h2><p>CLH 队列不是很像队列，因为它的入队和出队操作与其作为锁的用途密切相关。它是一个链接队列，通过两个原子可更新字段 <code>head</code> 和 <code>tail</code> 访问，它们最初都指向一个虚拟节点。</p><p><img src="`+i+`" alt="An image"></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>

        <span class="token comment">// 共享模式</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token constant">SHARED</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 独占模式</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token constant">EXCLUSIVE</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 取消状态</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CANCELLED</span> <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">// 表示需要唤醒</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SIGNAL</span>    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">// 阻塞等待</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CONDITION</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>

        <span class="token comment">// 值指示下一次获取 Shared 应该无条件传播</span>
        <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">PROPAGATE</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>

        <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>

        <span class="token comment">// 前驱</span>
        <span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span>
        <span class="token comment">// 后继续</span>
        <span class="token keyword">volatile</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>
        <span class="token comment">// 绑定线程</span>
        <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>

        <span class="token class-name">Node</span> nextWaiter<span class="token punctuation">;</span>

        <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> nextWaiter <span class="token operator">==</span> <span class="token constant">SHARED</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">NullPointerException</span> <span class="token punctuation">{</span>
            <span class="token class-name">Node</span> p <span class="token operator">=</span> prev<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                <span class="token keyword">return</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// Used to establish initial head or SHARED marker</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> thread<span class="token punctuation">,</span> <span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// Used by addWaiter</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> mode<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> thread<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> thread<span class="token punctuation">,</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Used by Condition</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>waitStatus <span class="token operator">=</span> waitStatus<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> thread<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="进队列" tabindex="-1"><a class="header-anchor" href="#进队列" aria-hidden="true">#</a> 进队列</h2><p>获取锁状态失败的时候，进入队列进行排队，涉及两段代码，分别为快速进队和循环进队列</p><ol><li>快速进队</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Try the fast path of enq; backup to full enq on failure</span>
    <span class="token class-name">Node</span> pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>
        <span class="token comment">// 快速进队，如果其他线程已经进队，进行循环进队</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>在快速进队失败的情况下，进行循环进队</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// Must initialize</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
                <span class="token keyword">return</span> t<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="出队列" tabindex="-1"><a class="header-anchor" href="#出队列" aria-hidden="true">#</a> 出队列</h2><ol><li>由于<code>head</code>是哑节点，所以在判断前驱为head的时候并且自己抢到锁，就可以出队了。</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 前驱为head，自己拿到锁</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 持有锁线程出队</span>
                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>
                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>真实出队，把线程信息移除，拿到锁的线程已经不在队列中，头节点依然是哑节点</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHead</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    head <span class="token operator">=</span> node<span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ul><li>线程协作，当前持有锁的线程在释放锁的时候，唤醒后继节点</li><li>后继线程节点拿到锁的时候，出队</li></ul><h2 id="参考材料" tabindex="-1"><a class="header-anchor" href="#参考材料" aria-hidden="true">#</a> 参考材料</h2><ul><li><a href=".">Michael-Scott</a></li></ul><p>本算法主要是将线程如何协作的</p>`,45),r={href:"https://book.douban.com/subject/10484692/",target:"_blank",rel:"noopener noreferrer"};function k(v,m){const s=l("ExternalLinkIcon");return e(),p("div",null,[d,n("ul",null,[n("li",null,[n("a",r,[t("Java并发编程实战 P273"),o(s)])])])])}const h=a(u,[["render",k],["__file","clh.html.vue"]]);export{h as default};

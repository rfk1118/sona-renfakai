import{_ as r,V as s,W as h,Y as e,a1 as a,Z as l,$ as n,a0 as d,F as o}from"./framework-1bd9c91b.js";const c="/assets/heap-array-51c4a551.png",u="/assets/down-3807b617.jpg",_="/assets/heap-siftup-7b674588.jpg",p="/assets/move-or-exchange-d36eb68f.jpg",f="/assets/heap-h1-1c386992.jpg",g="/assets/heap-h2-43a7530b.jpg",m={},b=e("h1",{id:"heap",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#heap","aria-hidden":"true"},"#"),a(" Heap")],-1),x=e("h2",{id:"使用场景",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#使用场景","aria-hidden":"true"},"#"),a(" 使用场景")],-1),k=e("li",null,"优先级队列（一般使用小顶堆）",-1),v=e("li",null,"堆排序 （一般使用大顶堆）",-1),j=e("li",null,"任务调度",-1),A={href:"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/",target:"_blank",rel:"noopener noreferrer"},w=d('<h2 id="堆排序优点" tabindex="-1"><a class="header-anchor" href="#堆排序优点" aria-hidden="true">#</a> 堆排序优点</h2><h3 id="时间空间复杂度" tabindex="-1"><a class="header-anchor" href="#时间空间复杂度" aria-hidden="true">#</a> 时间空间复杂度</h3><ul><li><code>merge sort</code>时间负责度;</li><li><code>insertion sort</code>空间复杂度。</li></ul><h2 id="堆特点" tabindex="-1"><a class="header-anchor" href="#堆特点" aria-hidden="true">#</a> 堆特点</h2><ul><li>完全二叉树（除了数组的最后一层节点不需要是满的）;</li><li>使用数组实现;</li></ul><div style="text-align:center;"><p><img src="'+c+'" alt="An image"> 图来自《算法导论》</p></div><ul><li>无须<code>left right</code>指针保存孩子节点，使用规约维持关系; <ul><li><code>PARENT(i) = Array[i/2]</code></li><li><code>LEFT(i) = Array[2*i]</code></li><li><code>RIGH(i) = Arriy[2*i+1]</code></li></ul></li><li>插入和删除节点复杂度<code>O(lgn)</code>。</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>根的位置为索引 0 或 1处，这是两种实现方案。</p></div><h2 id="二叉树搜索树区别" tabindex="-1"><a class="header-anchor" href="#二叉树搜索树区别" aria-hidden="true">#</a> 二叉树搜索树区别</h2><ul><li>相同点 <ul><li>父节点大于/小于子节点；</li></ul></li><li>不同点 <ul><li>使用规约代替指针维持关系；</li><li>弱序，同一父亲兄弟节点大小关系不定；</li><li>不支持遍历，想要获取数据只能一一推出，弱序决定的。</li></ul></li></ul><h2 id="核心功能" tabindex="-1"><a class="header-anchor" href="#核心功能" aria-hidden="true">#</a> 核心功能</h2><h3 id="下沉" tabindex="-1"><a class="header-anchor" href="#下沉" aria-hidden="true">#</a> 下沉</h3><ol><li>删除元素 <ul><li>删除第 0 个元素，所有数据全部向前移动</li><li>删除第 0 个元素，并将最后一个数据放置到索引 0 处，进行下沉</li></ul></li><li>进行下沉的示意图</li></ol><p><img src="'+u+'" alt="An image"></p><h3 id="上浮" tabindex="-1"><a class="header-anchor" href="#上浮" aria-hidden="true">#</a> 上浮</h3>',15),y=e("li",null,[a("在插入时候进行上浮，只需要与父亲节点进行比较，比较简单 "),e("img",{src:_,alt:"An image"})],-1),L=e("li",null,[a("插入元素使用交换还是移动，交换的方式比较容易理解，而移动的方式性能比较高，移动的更少，由于"),e("code",null,"PriorityQueue"),a("是由"),e("code",null,"Josh Bloch, Doug Lea"),a("两位大神写的，而且是基础包，性能优先。")],-1),B={href:"https://book.douban.com/subject/1144007/",target:"_blank",rel:"noopener noreferrer"},E=e("img",{src:p,alt:"An image"},null,-1),H=e("h3",{id:"堆化",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#堆化","aria-hidden":"true"},"#"),a(" 堆化")],-1),N=e("code",null,"heapify();",-1),V={href:"https://www.cs.usfca.edu/~galles/visualization/Heap.html",target:"_blank",rel:"noopener noreferrer"},J=e("code",null,"BuildHeap",-1),R=e("li",null,[a("先下沉最后一层父节点 "),e("img",{src:f,alt:"An image"})],-1),I=e("li",null,[a("在下沉倒数二次父亲节点 "),e("img",{src:g,alt:"An image"})],-1),P=e("h2",{id:"源码",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#源码","aria-hidden":"true"},"#"),a(" 源码")],-1),T=e("h2",{id:"参考资料",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#参考资料","aria-hidden":"true"},"#"),a(" 参考资料")],-1),z={href:"https://book.douban.com/subject/20432061/",target:"_blank",rel:"noopener noreferrer"},C={href:"https://book.douban.com/subject/1144007/",target:"_blank",rel:"noopener noreferrer"},F={href:"https://book.douban.com/subject/19952400/",target:"_blank",rel:"noopener noreferrer"},G={href:"https://www.cs.usfca.edu/~galles/visualization/Heap.html",target:"_blank",rel:"noopener noreferrer"};function S(D,K){const t=o("ExternalLinkIcon"),i=o("RouterLink");return s(),h("div",null,[b,x,e("ul",null,[k,v,j,e("li",null,[e("a",A,[a("数组中的第 K 个最大元素"),l(t)])])]),w,e("ol",null,[y,L,e("li",null,[a("交换还是移动，请参考"),e("a",B,[a("Java 数据结构和算法 P456"),l(t)]),E])]),H,e("ol",null,[e("li",null,[a("数组中填充了数据，这个时候需要堆话"),N,a("，按照层级从最后一层父节点开始下沉，推荐使用"),e("a",V,[a("堆工具"),l(t)]),a("，"),J,a("，并且放慢 Speed。")]),R,I]),P,e("ul",null,[e("li",null,[l(i,{to:"/languages/java/heap-java.html"},{default:n(()=>[a("Java版本")]),_:1})]),e("li",null,[l(i,{to:"/languages/go/heap-go.html"},{default:n(()=>[a("Go版本")]),_:1})])]),T,e("ul",null,[e("li",null,[e("a",z,[a("《算法导论（原书第3版）》"),l(t)])]),e("li",null,[e("a",C,[a("Java 数据结构和算法"),l(t)])]),e("li",null,[e("a",F,[a("算法（第 4 版）"),l(t)])]),e("li",null,[e("a",G,[a("堆工具"),l(t)])])])])}const Q=r(m,[["render",S],["__file","heap.html.vue"]]);export{Q as default};

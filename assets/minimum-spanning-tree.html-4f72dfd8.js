const e=JSON.parse('{"key":"v-50664900","path":"/basic-skill/algorithms/graphs/minimum-spanning-tree.html","title":"最小生成树","lang":"zh-CN","frontmatter":{"description":"最小生成树 概念 最小（权重）生成树算法从给定节点开始，找到其所有可到达的节点以及以可能的最小权重将节点连接在一起的一组关系。它从任何已访问节点遍历到下一个具有最低权重的未访问节点，从而避免循环。 第一个已知的最小权重生成树算法是由捷克科学家Otakar Borůvka于1926年开发的。Prim算法于1957年发明，是最简单和最著名的算法。 Prim的算法类似于Dijkstra的最短路径算法，但不是最小化以每个关系结束的路径的总长度，而是分别最小化每个关系的长度。与 Dijkstra 算法不同，它可以存在负权重关系。","head":[["meta",{"property":"og:url","content":"https://renfakai.com/basic-skill/algorithms/graphs/minimum-spanning-tree.html"}],["meta",{"property":"og:site_name","content":"天道酬勤"}],["meta",{"property":"og:title","content":"最小生成树"}],["meta",{"property":"og:description","content":"最小生成树 概念 最小（权重）生成树算法从给定节点开始，找到其所有可到达的节点以及以可能的最小权重将节点连接在一起的一组关系。它从任何已访问节点遍历到下一个具有最低权重的未访问节点，从而避免循环。 第一个已知的最小权重生成树算法是由捷克科学家Otakar Borůvka于1926年开发的。Prim算法于1957年发明，是最简单和最著名的算法。 Prim的算法类似于Dijkstra的最短路径算法，但不是最小化以每个关系结束的路径的总长度，而是分别最小化每个关系的长度。与 Dijkstra 算法不同，它可以存在负权重关系。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://renfakai.com/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-07T06:13:29.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"最小生成树"}],["meta",{"property":"article:modified_time","content":"2023-09-07T06:13:29.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"最小生成树\\",\\"image\\":[\\"https://renfakai.com/\\"],\\"dateModified\\":\\"2023-09-07T06:13:29.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":2,"title":"场景","slug":"场景","link":"#场景","children":[]},{"level":2,"title":"MST性质","slug":"mst性质","link":"#mst性质","children":[]},{"level":2,"title":"常见算法","slug":"常见算法","link":"#常见算法","children":[]},{"level":2,"title":"Prim","slug":"prim","link":"#prim","children":[{"level":3,"title":"Prim代码","slug":"prim代码","link":"#prim代码","children":[]}]},{"level":2,"title":"Kruskal","slug":"kruskal","link":"#kruskal","children":[{"level":3,"title":"Kruskal实现","slug":"kruskal实现","link":"#kruskal实现","children":[]},{"level":3,"title":"Kruskal代码","slug":"kruskal代码","link":"#kruskal代码","children":[]}]},{"level":2,"title":"结论","slug":"结论","link":"#结论","children":[]}],"git":{"createdTime":1694067209000,"updatedTime":1694067209000,"contributors":[{"name":"renfakai","email":"rfk1118@gmail.com","commits":1}]},"readingTime":{"minutes":4.84,"words":1451},"filePathRelative":"basic-skill/algorithms/graphs/minimum-spanning-tree.md","localizedDate":"2023年9月7日","excerpt":"<h1> 最小生成树</h1>\\n<h2> 概念</h2>\\n<p>最小（权重）生成树算法从给定节点开始，找到其所有可到达的节点以及以可能的最小权重将节点连接在一起的一组关系。它从任何已访问节点遍历到下一个具有最低权重的未访问节点，从而避免循环。</p>\\n<p>第一个已知的最小权重生成树算法是由捷克科学家<code>Otakar Borůvka</code>于1926年开发的。<code>Prim</code>算法于1957年发明，是最简单和最著名的算法。</p>\\n<p><code>Prim</code>的算法类似于<code>Dijkstra</code>的最短路径算法，但不是最小化以每个关系结束的路径的总长度，而是分别最小化每个关系的长度。与 <code>Dijkstra</code> 算法不同，它可以存在负权重关系。</p>","copyright":{},"autoDesc":true}');export{e as data};

import{_ as d,V as a,W as t,Y as e,a1 as c,Z as n,a0 as r,F as i}from"./framework-1bd9c91b.js";const h={},s=r('<h1 id="中间件" tabindex="-1"><a class="header-anchor" href="#中间件" aria-hidden="true">#</a> 中间件</h1><p>搭建项目时，按照敏捷规则不到万不得以不要使用中间件，使用中间件会增加代码层面成本（编写、维护）、中间件成本（搭建、维护）。 有些中间件是必不可少的，比如服务器（<code>Jetty、Undertow、Tomcat</code>），下面按照必要、非必要对中间件进行梳理。</p><h2 id="必要" tabindex="-1"><a class="header-anchor" href="#必要" aria-hidden="true">#</a> 必要</h2><h3 id="服务器" tabindex="-1"><a class="header-anchor" href="#服务器" aria-hidden="true">#</a> 服务器</h3><p>服务器一般都支持 <code>nio</code> 和<code>阻塞io</code>，服务器启动时使用 <code>nio 模型</code>。<code>Netty、Jetty、Undertow、Tomcat</code>都实现了<code>Reactor</code>模型，所以了解<code>Reactor</code>模型就等于学会了服务器容器，大公司内部会自定义轻量级Rpc服务器(基于Netty)。</p><h2 id="非必要" tabindex="-1"><a class="header-anchor" href="#非必要" aria-hidden="true">#</a> 非必要</h2><h3 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h3><p><code>Reactor</code> 中的 <code>acceptor</code> 属于<code>CPU密集型</code>，<code>handler</code>包含以下三种：<code>CPU密集型</code>、<code>IO 密集型</code>、<code>混合型</code>。 <code>Redis</code> 中的 <code>hanler</code> 是 <code>CPU 密集型</code>，所以设计成单线程就很合理。 对于服务器来讲，一般情况下 <code>handler</code> 为 <code>IO 密集型</code>、<code>混合型</code>，所以使用 <code>Redis</code> 是将 <code>IO 密集型</code>、<code>混合型</code>转换成 <code>CPU 密集型</code>，还有一种使用方式就是缓解 <code>CPU</code>压力而做缓存。</p>',8),l={class:"hint-container tip"},_=e("p",{class:"hint-container-title"},"提示",-1),u={href:"http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/cache-middleware.html",target:"_blank",rel:"noopener noreferrer"},p=e("h3",{id:"mq",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#mq","aria-hidden":"true"},"#"),c(" MQ")],-1),f=e("p",null,"MQ一般起到三个功能：解耦、异步、削峰填谷。",-1),m=e("ol",null,[e("li",null,"应用系统中调用三方系统，为了防止后面每增加一个三方系统都要修改代码，在解耦合方面 MQ 有点像观察者设计模式；"),e("li",null,"应用系统中调用三方系统，并不依赖三方系统（耗时长）结果，此时就可以使用 MQ 进行异步；"),e("li",null,[c("MQ 还可以做到“削峰填谷”的作用，如果全天只有一小段时间出现流量剧增，出现毛刺，就可以使用 MQ 进行应对。juc 内的 "),e("code",null,"BlockingQueue"),c(" 也是一个 MQ，只不过这个"),e("code",null,"Queue"),c("是基于任务的。")])],-1);function x(Q,b){const o=i("ExternalLinkIcon");return a(),t("div",null,[s,e("div",l,[_,e("p",null,[c("更加详细内容请参考 "),e("a",u,[c("周志明《凤凰架构 服务端缓存》"),n(o)])])]),p,f,m])}const R=d(h,[["render",x],["__file","index.html.vue"]]);export{R as default};

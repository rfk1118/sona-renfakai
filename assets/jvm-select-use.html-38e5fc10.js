import{_ as d,V as c,W as a,Y as s,X as e,a0 as l,$ as i,F as r}from"./framework-5793c714.js";const t="/assets/tenured-94b29657.jpg",n={},_=e("h1",{id:"生产使用",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#生产使用","aria-hidden":"true"},"#"),l(" 生产使用")],-1),p=e("p",null,[l("垃圾回收器的选择还是根据实际生产环境进行选择，选择主要根据两个指标"),e("code",null,"最大吞吐量、最短回收停顿时间"),l("。")],-1),u=e("p",null,[l("最大吞吐量使用的是"),e("code",null,"标记-整理"),l("算法，整理过程中需要重新移动对象，所以耗时增加，但是堆内存空间不需要额外的空闲表进行记录，所以在分配对象时间比较快，其流程如下：")],-1),m=i('<p>最短回收停顿时间使用<code>标记-清除</code>算法，由于没有对象的移动，仅仅需要将是释放空间记录到空闲表中，所以垃圾回收阶段停顿时间少，但是在对象分配的时候需要查找空闲表，所以在吞吐量降低</p><p>现以常用版本<code>jdk1.8</code>为案例进行讲解，现使用下图进行组合:</p><p><img src="'+t+'" alt="An image"></p><ol><li><code>标记-整理</code>主要包含<code>Serial Old、Parallel Old</code>，最大吞吐量进行组合时可以使用，<code>Serial Old</code>在老年代使用单线程，回收较慢，不建议作为老年代主要回收器使用，服务器一般都是web项目。 <ul><li><s><code>Serial + Serial Old</code></s> 仅客户端应用建议使用</li><li><s><code>ParNew + Serial Old</code></s> 新生代多线程回收很快，老年代单线程回收慢，不建议使用</li><li><s><code>Parallel Scavenge + Serial Old</code></s> 新生代多线程回收很快，老年代单线程回收慢，不建议使用</li><li><code>Parallel Scavenge + Parallel Old</code> 新生代、老年代都使用多线程，如果峰值应用程序性能是第一个优先级，并且没有暂停时间要求或暂停1秒或更长时间是可以接受的，那么让VM选择集器，或选择带有<code>-XX:+UseParallelGC</code>的并行收集器</li></ul></li><li><code>标记-清除</code>主要包含<code>CMS</code><ul><li><s><code>Serial + CMS</code></s> 新生代回收频率高，单线程版本导致应用<code>最短回收停顿时间</code>并未实现</li><li><code>ParNew + CMS +Serial Old</code> 常用版本，<code>CMS</code>在垃圾回收的时候会让内存碎片化，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次<code>Full GC</code>的情况，所以需要<code>Serial Old</code>进行辅助</li></ul></li></ol>',4);function S(h,f){const o=r("Mermaid");return c(),a("div",null,[_,p,u,s(o,{id:"mermaid-9",code:"eJxLL0osyFDwCeJSAALH6OdT5j/rmPBkx5Zn07c9m7rhWe+6Zws6YhV0de0UnKKfLWh/sW7Dsy27n3ateLp+54uNC2PB2pzA8s7RL9YtfL5u+rNpG57O2fB0bgNE0hks6RL9bPYWoMyznvaXkzogMi5gGdfopxvaIKY9Xw42uWMDUOGTvb3P966L5QIAxfRROA=="}),m])}const P=d(n,[["render",S],["__file","jvm-select-use.html.vue"]]);export{P as default};

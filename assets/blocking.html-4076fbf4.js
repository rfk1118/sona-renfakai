const e=JSON.parse('{"key":"v-a91c37b6","path":"/languages/java/thread/java/juc/blocking.html","title":"LockSupport","lang":"zh-CN","frontmatter":{"description":"LockSupport 在 JSR166 之前，没有 Java API 可用于阻塞和解除阻塞线程以创建不基于内置监视器的同步器。唯一的候选对象是 Thread.suspend 和 Thread.resume，它们无法使用，因为它们遇到了无法解决的竞争问题：如果解除阻塞的线程在阻塞线程执行 suspend之前调用了 resume，则恢复操作将无效。 java.util.concurrent.locks 包包含一个 LockSupport 类，其中包含解决此问题的方法。方法 LockSupport.park 阻塞当前线程，除非或直到发出 LockSupport.unpark。 （也允许虚假唤醒。）取消驻留的呼叫不“计数”，因此在驻留之前多次取消驻留只会解除对单个驻留的阻塞。此外，这适用于每个线程，而不是每个同步器。由于先前使用的“剩余” unpark，在新同步器上调用 park 的线程可能会立即返回。然而，在没有 unpark 的情况下，它的下一次调用将被阻塞。虽然可以明确清除此状态，但这样做是不值得的。在需要时多次调用 park 会更有效率。","head":[["meta",{"property":"og:url","content":"https://renfakai.com/languages/java/thread/java/juc/blocking.html"}],["meta",{"property":"og:site_name","content":"天道酬勤"}],["meta",{"property":"og:title","content":"LockSupport"}],["meta",{"property":"og:description","content":"LockSupport 在 JSR166 之前，没有 Java API 可用于阻塞和解除阻塞线程以创建不基于内置监视器的同步器。唯一的候选对象是 Thread.suspend 和 Thread.resume，它们无法使用，因为它们遇到了无法解决的竞争问题：如果解除阻塞的线程在阻塞线程执行 suspend之前调用了 resume，则恢复操作将无效。 java.util.concurrent.locks 包包含一个 LockSupport 类，其中包含解决此问题的方法。方法 LockSupport.park 阻塞当前线程，除非或直到发出 LockSupport.unpark。 （也允许虚假唤醒。）取消驻留的呼叫不“计数”，因此在驻留之前多次取消驻留只会解除对单个驻留的阻塞。此外，这适用于每个线程，而不是每个同步器。由于先前使用的“剩余” unpark，在新同步器上调用 park 的线程可能会立即返回。然而，在没有 unpark 的情况下，它的下一次调用将被阻塞。虽然可以明确清除此状态，但这样做是不值得的。在需要时多次调用 park 会更有效率。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-15T08:14:39.000Z"}],["meta",{"property":"article:modified_time","content":"2023-02-15T08:14:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"LockSupport\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-02-15T08:14:39.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":2,"title":"代码","slug":"代码","link":"#代码","children":[]},{"level":2,"title":"代码解释","slug":"代码解释","link":"#代码解释","children":[{"level":3,"title":"park(Object blocker)","slug":"park-object-blocker","link":"#park-object-blocker","children":[]},{"level":3,"title":"unpark(Thread thread)","slug":"unpark-thread-thread","link":"#unpark-thread-thread","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1676448879000,"updatedTime":1676448879000,"contributors":[{"name":"renfakai","email":"rfk1118@gmail.com","commits":1}]},"readingTime":{"minutes":2.06,"words":619},"filePathRelative":"languages/java/thread/java/juc/blocking.md","localizedDate":"2023年2月15日","excerpt":"<h1> LockSupport</h1>\\n<p>在 <code>JSR166</code> 之前，没有 <code>Java API</code> 可用于阻塞和解除阻塞线程以创建不基于内置监视器的同步器。唯一的候选对象是 <code>Thread.suspend</code> 和 <code>Thread.resume</code>，它们无法使用，因为它们遇到了无法解决的竞争问题：如果解除阻塞的线程在阻塞线程执行 <code>suspend</code>之前调用了 <code>resume</code>，则恢复操作将无效。</p>\\n<p><code>java.util.concurrent.locks</code> 包包含一个 <code>LockSupport</code> 类，其中包含解决此问题的方法。方法 <code>LockSupport.park</code> 阻塞当前线程，除非或直到发出 <code>LockSupport.unpark</code>。 （也允许虚假唤醒。）取消驻留的呼叫不“计数”，因此在驻留之前多次取消驻留只会解除对单个驻留的阻塞。此外，这适用于每个线程，而不是每个同步器。由于先前使用的“剩余” unpark，在新同步器上调用 park 的线程可能会立即返回。然而，在没有 unpark 的情况下，它的下一次调用将被阻塞。虽然可以明确清除此状态，但这样做是不值得的。在需要时多次调用 park 会更有效率。</p>","copyright":{},"autoDesc":true}');export{e as data};

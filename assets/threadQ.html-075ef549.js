import{_ as l,V as i,W as t,Y as a,a1 as n,Z as o,a0 as e,F as c}from"./framework-e54e0297.js";const r={},p=e(`<h1 id="线程池面试题" tabindex="-1"><a class="header-anchor" href="#线程池面试题" aria-hidden="true">#</a> 线程池面试题</h1><h2 id="线程池都有哪些参数" tabindex="-1"><a class="header-anchor" href="#线程池都有哪些参数" aria-hidden="true">#</a> 线程池都有哪些参数？</h2><p>这个问题是很好回答的，只要自己画过流程图，都能说出来，今天使用不同角度写一下每个参数的意义和容易错的点。</p><ul><li>核心线程</li><li>最大线程</li><li>设置队列</li><li>拒绝策略</li><li>回收时间限制</li></ul><h2 id="core" tabindex="-1"><a class="header-anchor" href="#core" aria-hidden="true">#</a> core</h2><p>核心线程，在接收请求时处理问题核心，当线程小于核心线程时，直接增加线程，一般情况下不会设置很大。</p><h2 id="max" tabindex="-1"><a class="header-anchor" href="#max" aria-hidden="true">#</a> max</h2><p>最大数量线程，当队列满的时候创建的最大线程，如果线程满了，处理任务数据还解决不了的话就需要考虑如何丢失任务策略。 而max不要使用Integer.MAX_VALUE。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span>
                                  <span class="token number">60L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>
                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>如果队列使用无边界队列就会导致core线程满了之后，任务进入到队列里面，而队列是无边界的，则不会在创建<code>max - core</code>这部分线程。</p></div><ol><li>xss设置了大小，当线程数量很多的时候也会导致oom;</li><li>线程数量很多的时候，队列加锁情况下会导致竞态加剧，参考非公平锁性能比公平锁要高。</li></ol><h2 id="丢弃任务策略" tabindex="-1"><a class="header-anchor" href="#丢弃任务策略" aria-hidden="true">#</a> 丢弃任务策略</h2><p>丢弃策略是为了保护服务可用，来看下redis最新也支持了内存淘汰策略，其实这里一样，都是为了保护服务而创建的，其实这里的淘汰策略和redis目的是一致的。</p>`,13),d={class:"hint-container tip"},u=a("p",{class:"hint-container-title"},"提示",-1),h={href:"https://javaguide.cn/database/redis/redis-questions-01.html#%E8%BF%87%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E4%B9%88",target:"_blank",rel:"noopener noreferrer"},k=e('<ol><li>volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol><li>volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li><li>allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol><h2 id="队列" tabindex="-1"><a class="header-anchor" href="#队列" aria-hidden="true">#</a> 队列</h2><p>我们知道线程最主要的作用就是削峰填谷，kafka也是，队列很重要。</p><ol><li>考虑如果队列可以无限扩张，一直扩张到无法分配内存，这时候服务会怎么样，会oom；</li><li>考虑如果队列可以无限扩展，一直打不满，则就不会扩张到max，削峰填谷的能力被大大削弱。</li></ol><h2 id="回收时间" tabindex="-1"><a class="header-anchor" href="#回收时间" aria-hidden="true">#</a> 回收时间</h2><p>资源回收。</p><h2 id="结论" tabindex="-1"><a class="header-anchor" href="#结论" aria-hidden="true">#</a> 结论</h2><ol><li>回收机制 <ol><li>线程资源回收</li><li>任务策略拒绝</li></ol></li><li>内存管理 <ol><li>线程数量保证不会oom（xss * count &gt; heap)</li><li>队列不会无限扩张导致oom</li></ol></li><li>削峰填谷 <ol><li>队列</li><li>处理任务能力，线程数量不可太小，也不可太大</li></ol></li></ol>',10);function m(v,x){const s=c("ExternalLinkIcon");return i(),t("div",null,[p,a("div",d,[u,a("p",null,[n("以下内容"),a("a",h,[n("参考JavaGuide(Java面试+学习指南)"),o(s)])])]),k])}const b=l(r,[["render",m],["__file","threadQ.html.vue"]]);export{b as default};

(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{291:function(t,e,a){t.exports=a.p+"assets/img/heap-array.25fc7fc6.png"},292:function(t,e,a){t.exports=a.p+"assets/img/down.c4d548a0.jpg"},293:function(t,e,a){t.exports=a.p+"assets/img/heap-siftup.9aa2d948.jpg"},294:function(t,e,a){t.exports=a.p+"assets/img/move-or-exchange.27405672.jpg"},295:function(t,e,a){t.exports=a.p+"assets/img/heap-h1.bca15db9.jpg"},296:function(t,e,a){t.exports=a.p+"assets/img/heap-h2.4f5c7b55.jpg"},451:function(t,e,a){"use strict";a.r(e);var r=a(8),v=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"heap"}},[t._v("Heap")]),t._v(" "),e("h2",{attrs:{id:"使用场景"}},[t._v("使用场景")]),t._v(" "),e("ul",[e("li",[t._v("优先级队列（一般使用小顶堆）")]),t._v(" "),e("li",[t._v("堆排序 （一般使用大顶堆）")]),t._v(" "),e("li",[t._v("任务调度")]),t._v(" "),e("li",[e("a",{attrs:{href:"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/",target:"_blank",rel:"noopener noreferrer"}},[t._v("数组中的第 K 个最大元素"),e("OutboundLink")],1)])]),t._v(" "),e("h2",{attrs:{id:"堆排序优点"}},[t._v("堆排序优点")]),t._v(" "),e("h3",{attrs:{id:"时间空间复杂度"}},[t._v("时间空间复杂度")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("merge sort")]),t._v("时间负责度;")]),t._v(" "),e("li",[e("code",[t._v("insertion sort")]),t._v("空间复杂度。")])]),t._v(" "),e("h2",{attrs:{id:"堆特点"}},[t._v("堆特点")]),t._v(" "),e("ul",[e("li",[t._v("完全二叉树（除了数组的最后一层节点不需要是满的）;")]),t._v(" "),e("li",[t._v("使用数组实现;")])]),t._v(" "),e("div",{staticClass:"custom-block center"},[e("p",[e("img",{attrs:{src:a(291),alt:"An image"}}),t._v("\n图来自《算法导论》")])]),t._v(" "),e("ul",[e("li",[t._v("无须"),e("code",[t._v("left right")]),t._v("指针保存孩子节点，使用规约维持关系;\n"),e("ul",[e("li",[e("code",[t._v("PARENT(i) = Array[i/2]")])]),t._v(" "),e("li",[e("code",[t._v("LEFT(i) = Array[2*i]")])]),t._v(" "),e("li",[e("code",[t._v("RIGH(i) = Arriy[2*i+1]")])])])]),t._v(" "),e("li",[t._v("插入和删除节点复杂度"),e("code",[t._v("O(lgn)")]),t._v("。")])]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),e("p",[t._v("根的位置为索引 0 或 1处，这是两种实现方案。")])]),t._v(" "),e("h2",{attrs:{id:"二叉树搜索树区别"}},[t._v("二叉树搜索树区别")]),t._v(" "),e("ul",[e("li",[t._v("相同点\n"),e("ul",[e("li",[t._v("父节点大于/小于子节点；")])])]),t._v(" "),e("li",[t._v("不同点\n"),e("ul",[e("li",[t._v("使用规约代替指针维持关系；")]),t._v(" "),e("li",[t._v("弱序，同一父亲兄弟节点大小关系不定；")]),t._v(" "),e("li",[t._v("不支持遍历，想要获取数据只能一一推出，弱序决定的。")])])])]),t._v(" "),e("h2",{attrs:{id:"核心功能"}},[t._v("核心功能")]),t._v(" "),e("h3",{attrs:{id:"下沉"}},[t._v("下沉")]),t._v(" "),e("ol",[e("li",[t._v("删除元素\n"),e("ul",[e("li",[t._v("删除第 0 个元素，所有数据全部向前移动")]),t._v(" "),e("li",[t._v("删除第 0 个元素，并将最后一个数据放置到索引 0 处，进行下沉")])])]),t._v(" "),e("li",[t._v("进行下沉的示意图")])]),t._v(" "),e("p",[e("img",{attrs:{src:a(292),alt:"An image"}})]),t._v(" "),e("h3",{attrs:{id:"上浮"}},[t._v("上浮")]),t._v(" "),e("ol",[e("li",[t._v("在插入时候进行上浮，只需要与父亲节点进行比较，比较简单\n"),e("img",{attrs:{src:a(293),alt:"An image"}})]),t._v(" "),e("li",[t._v("插入元素使用交换还是移动，交换的方式比较容易理解，而移动的方式性能比较高，移动的更少，由于"),e("code",[t._v("PriorityQueue")]),t._v("是由"),e("code",[t._v("Josh Bloch, Doug Lea")]),t._v("两位大神写的，而且是基础包，性能优先。")]),t._v(" "),e("li",[t._v("交换还是移动，请参考"),e("a",{attrs:{href:"https://book.douban.com/subject/1144007/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java 数据结构和算法 P456"),e("OutboundLink")],1),t._v(" "),e("img",{attrs:{src:a(294),alt:"An image"}})])]),t._v(" "),e("h3",{attrs:{id:"堆化"}},[t._v("堆化")]),t._v(" "),e("ol",[e("li",[t._v("数组中填充了数据，这个时候需要堆话"),e("code",[t._v("heapify();")]),t._v("，按照层级从最后一层父节点开始下沉，推荐使用"),e("a",{attrs:{href:"https://www.cs.usfca.edu/~galles/visualization/Heap.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("堆工具"),e("OutboundLink")],1),t._v("，"),e("code",[t._v("BuildHeap")]),t._v("，并且放慢 Speed。")]),t._v(" "),e("li",[t._v("先下沉最后一层父节点\n"),e("img",{attrs:{src:a(295),alt:"An image"}})]),t._v(" "),e("li",[t._v("在下沉倒数二次父亲节点\n"),e("img",{attrs:{src:a(296),alt:"An image"}})])]),t._v(" "),e("h2",{attrs:{id:"源码"}},[t._v("源码")]),t._v(" "),e("ul",[e("li",[e("RouterLink",{attrs:{to:"/languages/java/heap-java.html"}},[t._v("Java版本")])],1),t._v(" "),e("li",[e("RouterLink",{attrs:{to:"/languages/go/heap-go.html"}},[t._v("Go版本")])],1)]),t._v(" "),e("h2",{attrs:{id:"参考资料"}},[t._v("参考资料")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://book.douban.com/subject/20432061/",target:"_blank",rel:"noopener noreferrer"}},[t._v("《算法导论（原书第3版）》"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://book.douban.com/subject/1144007/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java 数据结构和算法"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://book.douban.com/subject/19952400/",target:"_blank",rel:"noopener noreferrer"}},[t._v("算法（第 4 版）"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://www.cs.usfca.edu/~galles/visualization/Heap.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("堆工具"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=v.exports}}]);
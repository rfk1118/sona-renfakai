const e=JSON.parse('{"key":"v-722252f3","path":"/languages/java/thread/java/juc/aos.html","title":"exclusively","lang":"zh-CN","frontmatter":{"description":"exclusively 线程独占拥有的同步器。此类为创建所有权概念的锁和相关同步器提供了基础。AbstractOwnableSynchronizer类本身不管理或使用此信息。但是，子类和工具可以使用适当维护的值来帮助控制和监视访问并提供诊断。 核心api setExclusiveOwnerThread(Thread thread) setExclusiveOwnerThread(Thread.currentThread());访问权限的线程 setExclusiveOwnerThread(null);清空访问权限的线程，都可以访问 getExclusiveOwnerThread() 返回最后由setExclusiveOwnerThread设置的线程，如果从未设置，则返回null","head":[["meta",{"property":"og:url","content":"https://renfakai.com/languages/java/thread/java/juc/aos.html"}],["meta",{"property":"og:site_name","content":"天道酬勤"}],["meta",{"property":"og:title","content":"exclusively"}],["meta",{"property":"og:description","content":"exclusively 线程独占拥有的同步器。此类为创建所有权概念的锁和相关同步器提供了基础。AbstractOwnableSynchronizer类本身不管理或使用此信息。但是，子类和工具可以使用适当维护的值来帮助控制和监视访问并提供诊断。 核心api setExclusiveOwnerThread(Thread thread) setExclusiveOwnerThread(Thread.currentThread());访问权限的线程 setExclusiveOwnerThread(null);清空访问权限的线程，都可以访问 getExclusiveOwnerThread() 返回最后由setExclusiveOwnerThread设置的线程，如果从未设置，则返回null"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://renfakai.com/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-02-25T03:30:19.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"exclusively"}],["meta",{"property":"article:modified_time","content":"2023-02-25T03:30:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"exclusively\\",\\"image\\":[\\"https://renfakai.com/\\"],\\"dateModified\\":\\"2023-02-25T03:30:19.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"核心api","slug":"核心api","link":"#核心api","children":[]},{"level":2,"title":"继承关系","slug":"继承关系","link":"#继承关系","children":[]},{"level":2,"title":"代码","slug":"代码","link":"#代码","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1677295819000,"updatedTime":1677295819000,"contributors":[{"name":"renfakai","email":"rfk1118@gmail.com","commits":1}]},"readingTime":{"minutes":0.8,"words":239},"filePathRelative":"languages/java/thread/java/juc/aos.md","localizedDate":"2023年2月25日","excerpt":"<h1> exclusively</h1>\\n<p>线程独占拥有的同步器。此类为创建所有权概念的锁和相关同步器提供了基础。<code>AbstractOwnableSynchronizer</code>类本身不管理或使用此信息。但是，子类和工具可以使用适当维护的值来帮助控制和监视访问并提供诊断。</p>\\n<h2> 核心api</h2>\\n<p></p>\\n<ul>\\n<li>setExclusiveOwnerThread(Thread thread)\\n<ul>\\n<li><code>setExclusiveOwnerThread(Thread.currentThread());</code>访问权限的线程</li>\\n<li><code>setExclusiveOwnerThread(null);</code>清空访问权限的线程，都可以访问</li>\\n</ul>\\n</li>\\n<li>getExclusiveOwnerThread()\\n<ul>\\n<li>返回最后由<code>setExclusiveOwnerThread</code>设置的线程，如果从未设置，则返回null</li>\\n</ul>\\n</li>\\n</ul>","copyright":{},"autoDesc":true}');export{e as data};

import{_ as r,V as d,W as c,X as e,a0 as t,Y as o,Z as s,$ as i,F as l}from"./framework-fd210779.js";const h="/assets/components-4de4964d.png",u={},_=e("h1",{id:"netty",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#netty","aria-hidden":"true"},"#"),t(" Netty")],-1),p={class:"hint-container tip"},f=e("p",{class:"hint-container-title"},"提示",-1),b={href:"https://book.douban.com/subject/27038538/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://netty.io",target:"_blank",rel:"noopener noreferrer"},y={style:{"text-align":"center"}},O=e("img",{src:h,alt:"An image"},null,-1),k={href:"https://netty.io",target:"_blank",rel:"noopener noreferrer"},x=e("code",null,"Netty、Jetty、Undertow、Tomcat",-1),I=e("a",{href:"./doug-lea/nio.pdf"},"Reactor模型",-1),N=e("code",null,"Tomcat、Jetty、Undertow",-1),g=e("code",null,"Netty",-1),v={href:"https://book.douban.com/subject/27038538/",target:"_blank",rel:"noopener noreferrer"},B=i('<h2 id="名词解释" tabindex="-1"><a class="header-anchor" href="#名词解释" aria-hidden="true">#</a> 名词解释</h2><ul><li>Accept为服务器创建连接的，一般情况下为CPU密集型，不会成为阻塞点；</li><li>Handler为服务器处理任务抽象，其包含CPU密集型、IO密集型、混合型。 <ul><li>CPU密集型主要处理内存中的数据，例如Redis；</li><li>IO密集型主要从磁盘读取数据，例如Mysql、Oracle等。</li></ul></li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>一般情况下业务服务器都会涉及到磁盘读取数据，主要为IO密集型、混合型，所以在做优化时，使用Redis缓存其根本原因是将两种类型转换成CPU密集型</p></div><h2 id="设计理念" tabindex="-1"><a class="header-anchor" href="#设计理念" aria-hidden="true">#</a> 设计理念</h2><p>设计项目，需要思考那些因素，无论是开源项目还是业务项目，一般情况下按照三个方向去考虑。</p>',5),C=e("li",null,[t("解耦合，业务与领域关注点分离，例如"),e("code",null,"Netty"),t("将业务和网络解耦合；")],-1),j={href:"https://book.douban.com/subject/30333919/",target:"_blank",rel:"noopener noreferrer"},A=e("code",null,"Component",-1),G={href:"https://github.com/rfk1118/books/blob/main/doug/groups.pdf",target:"_blank",rel:"noopener noreferrer"},J=e("code",null,"bean",-1),L=e("li",null,"可测试性，可测试性是保证大型系统稳定性的保证，可以在开发、测试阶段暴露问题，而不是将问题推迟到外部引用（开源项目）、线上（业务系统）。",-1),P=e("h3",{id:"可伸缩性",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#可伸缩性","aria-hidden":"true"},"#"),t(" 可伸缩性")],-1),R=e("p",null,[t("可伸缩性可以应用到服务器层面和代码层面，服务器一般为"),e("code",null,"Serverless"),t("，可伸缩性使用"),e("code",null,"k8s"),t("的编排能力即可，程序员更多的关注代码层面处理，代码层面包含以下特征：")],-1),S=e("li",null,"Selector使得我们能够通过较少的线程便可监视许多连接上的事件。",-1),U=i('<h2 id="io" tabindex="-1"><a class="header-anchor" href="#io" aria-hidden="true">#</a> IO</h2><h3 id="bio" tabindex="-1"><a class="header-anchor" href="#bio" aria-hidden="true">#</a> BIO</h3><p>BIO同步阻塞IO，使用同步阻塞IO时，因为其阻塞原因，需要将<code>Accept</code>的连接交接给其他线程做处理，其他线程可以使用每次创建、池话两种处理方式处理。</p><ol><li>任何时候都可能有大量的线程处于休眠状态，只是等待输入或者输出数据就绪，会产生资源浪费；</li><li>需要为每个线程的调用栈都分配内存，其默认值 大小区间为 64 KB 到 1 MB，具体取决于操作系统； <ul><li>关于这里有一些补充，例如在<code>Jvm</code>中<code>Xss 参数</code>指定的情况下，如果无限制的创建线程也会导致OOM；</li></ul></li><li>Java 虚拟机在物理上可以支持非常大数量的线程，但是远在到达该极限之前，上下文切换（从内存加载数据到寄存器或虚拟机栈）所带来的开销会很大。Java代码中经典案例是Juc非公平锁，非公平锁下当被唤醒节点被唤醒到抢占锁这段时间（内核线程调度、上下文加载）会被其他线程抢占先机，这也就是为什么非公平锁性能很高。 <ul><li>寄存器数据加载，普通寄存器（加载运行数据）、CS、IP寄存器（代码运行指示器）等；</li><li>虚拟机栈加载，对栈帧加载，PC寄存器加载等；</li></ul></li></ol><p>在此基础上，使用池话可以降低创建线程的开销，但无法解决线程阻塞等待资源问题。</p><h3 id="nio" tabindex="-1"><a class="header-anchor" href="#nio" aria-hidden="true">#</a> NIO</h3><p>NIO同步非阻塞IO，使用非阻塞IO时，将<code>Accept</code>的连接交接给其他线程做处理，其他线程可以使用每次创建、池话两种处理方式处理。</p><p>使用每次创建是不太合理的，线程在不阻塞时间段是可以处理其他任务的，所以使用池话比较合理，使用池话可以使用少量线程处理大量任务，<code>handler</code>生命周期和任务固定的情况下，线程会一直运行不会被销毁，其和<code>Juc</code>线程下的<code>work</code>理论是一致的，所以其性能相当高，与<code>Go</code>语言的<code>GPM</code>基本一致。</p><ol><li>使用较少的线程便可以处理许多连接，因此也减少了内存管理和上下文切换所带来开销;</li><li>当没有 <code>I/O</code> 操作需要处理的时候，线程也可以被用于其他任务。</li></ol><h3 id="aio" tabindex="-1"><a class="header-anchor" href="#aio" aria-hidden="true">#</a> AIO</h3><p>AIO为异步非阻塞IO，在BSD、Linux系统上支持不是很好，在Windows上支持比较好，而服务器一般部署在Linux系统上。Netty5时基于AIO进行编写的，使用<code>BenchMark</code>对Netty5和Netty4进行对比，发现Netty5性能上没有质变差异，并且代码量复杂高，维护成本非常高，所以社区对<code>Netty5</code>进行废弃，不在维护。</p><h3 id="池话线程多还是少" tabindex="-1"><a class="header-anchor" href="#池话线程多还是少" aria-hidden="true">#</a> 池话线程多还是少</h3><p>池话线程是一个需要动态调整的过程，主要包含一下原因：</p><ol><li>线程较少，导致某些任务排队过长；</li><li>线程较多，导致休眠、上下文切换竞争加剧问题。</li></ol><h2 id="netty-nio为什么性能高" tabindex="-1"><a class="header-anchor" href="#netty-nio为什么性能高" aria-hidden="true">#</a> Netty NIO为什么性能高</h2><ul><li>线程常驻，不会产生上下文切换；</li><li>BossGroup（一般情况下一个线程）监控连接，并创建连接；</li><li>WorkGroup生命周期按照模版进行处理，Channel处理是基于Selector事件进行处理；</li><li>BossGroup向WorkGroup异步提交任务；</li><li>NioEventLoop无锁设计；</li><li>对内存数据管理机制。</li></ul>',16);function w(M,V){const n=l("ExternalLinkIcon"),a=l("RouterLink");return d(),c("div",null,[_,e("div",p,[f,e("p",null,[t("本篇文章很多概念和思想来源于"),e("a",b,[t("《Netty 实战》"),o(n)])])]),e("p",null,[e("a",m,[t("Netty"),o(n)]),t(" 是一款异步事件驱动的网络应用程序框架，支持快速地开发可维护的、高性能的、面向协议的服务器和客户端。")]),e("div",y,[e("p",null,[O,t("图来自"),e("a",k,[t("官网"),o(n)])])]),e("p",null,[x,t(" 是 "),I,t("实践者， "),N,t("是以服务器形式存在的，"),g,t("则是被大量应到到轻量级Rpc框架中， 优秀应用案例可以从"),e("a",v,[t("《Netty 实战》"),o(n)]),t("中进行了解。")]),B,e("ol",null,[C,e("li",null,[t("模块化、复用性； "),e("ul",null,[e("li",null,[t("模块化，保证包依赖的传递性，越是底层包越需要稳定，服务依赖亦是如此，可以参考"),e("a",j,[t("《结构整洁之道》 第14章 组件耦合"),o(n)]),t("关于"),A,t("依赖讲解；")]),e("li",null,[t("复用性，"),e("a",G,[t("Doug lea 《Objects in Groups》"),o(n)]),t("讲了"),J,t("的不被侵入性，保证复用性。")])])]),L]),P,R,e("ol",null,[e("li",null,[t("非阻塞网络调用使得我们可以不必等待一个操作的完成。完全异步的 I/O 正是基于这个特性构建的，并且更进一步异步方法会立即返回，并且在它完成时，会直接或者在稍后的某个时间点通知用户，关于异步转同步可以查看"),o(a,{to:"/languages/java/thread/java/juc/future.html"},{default:s(()=>[t("Future")]),_:1}),t("。")]),S]),U])}const W=r(u,[["render",w],["__file","index.html.vue"]]);export{W as default};

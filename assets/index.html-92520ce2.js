import{_ as d,V as r,W as a,Y as e,a1 as o,Z as t,a0 as n,F as i}from"./framework-e54e0297.js";const s={},h=n('<h1 id="中间件" tabindex="-1"><a class="header-anchor" href="#中间件" aria-hidden="true">#</a> 中间件</h1><p>搭建项目时，按照敏捷规则不到万不得以不要使用中间件，使用中间件会增加代码层面成本（编写、维护）、中间件成本（搭建、维护）。 有些中间件是必不可少的，比如服务器（<code>Jetty、Undertow、Tomcat</code>），下面按照必要、非必要对中间件进行梳理。</p><h2 id="必要" tabindex="-1"><a class="header-anchor" href="#必要" aria-hidden="true">#</a> 必要</h2><p>使用<code>docker compose</code>部署项目。</p><h3 id="nginx" tabindex="-1"><a class="header-anchor" href="#nginx" aria-hidden="true">#</a> nginx</h3>',5),l={href:"https://bbs.huaweicloud.com/blogs/298643",target:"_blank",rel:"noopener noreferrer"},_=e("li",null,"代理（正向，反）",-1),p={href:"https://nginx.org/en/docs/http/load_balancing.html",target:"_blank",rel:"noopener noreferrer"},u=e("a",{href:"/middleware/netty/nio/selectors/chooser-factory"},"策略",-1),f={class:"hint-container tip"},x=e("p",{class:"hint-container-title"},"提示",-1),m={href:"http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/load-balancing.html",target:"_blank",rel:"noopener noreferrer"},g={start:"3"},b={href:"http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/",target:"_blank",rel:"noopener noreferrer"},y=n('<h3 id="服务器" tabindex="-1"><a class="header-anchor" href="#服务器" aria-hidden="true">#</a> 服务器</h3><p>服务器一般都支持 <code>nio</code> 和<code>阻塞io</code>，服务器启动时使用 <code>nio 模型</code>。<code>Netty、Jetty、Undertow、Tomcat</code>都实现了<code>Reactor</code>模型，所以了解<code>Reactor</code>模型就等于学会了服务器容器，大公司内部会自定义轻量级Rpc服务器(基于Netty)。</p><h2 id="非必要" tabindex="-1"><a class="header-anchor" href="#非必要" aria-hidden="true">#</a> 非必要</h2><h3 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h3><p><code>Reactor</code> 中的 <code>acceptor</code> 属于<code>CPU密集型</code>，<code>handler</code>包含以下三种：<code>CPU密集型</code>、<code>IO 密集型</code>、<code>混合型</code>。 <code>Redis</code> 中的 <code>hanler</code> 是 <code>CPU 密集型</code>，所以设计成单线程就很合理。 对于服务器来讲，一般情况下 <code>handler</code> 为 <code>IO 密集型</code>、<code>混合型</code>，所以使用 <code>Redis</code> 是将 <code>IO 密集型</code>、<code>混合型</code>转换成 <code>CPU 密集型</code>，还有一种使用方式就是缓解 <code>CPU</code>压力而做缓存。</p>',5),k={class:"hint-container tip"},v=e("p",{class:"hint-container-title"},"提示",-1),Q={href:"http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/cache-middleware.html",target:"_blank",rel:"noopener noreferrer"},M=e("h3",{id:"mq",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#mq","aria-hidden":"true"},"#"),o(" MQ")],-1),N=e("p",null,"MQ一般起到三个功能：解耦、异步、削峰填谷。",-1),R=e("ol",null,[e("li",null,"应用系统中调用三方系统，为了防止后面每增加一个三方系统都要修改代码，在解耦合方面 MQ 有点像观察者设计模式；"),e("li",null,"应用系统中调用三方系统，并不依赖三方系统（耗时长）结果，此时就可以使用 MQ 进行异步；"),e("li",null,[o("MQ 还可以做到“削峰填谷”的作用，如果全天只有一小段时间出现流量剧增，出现毛刺，就可以使用 MQ 进行应对。juc 内的 "),e("code",null,"BlockingQueue"),o(" 也是一个 MQ，只不过这个"),e("code",null,"Queue"),o("是基于任务的。")])],-1);function U(C,w){const c=i("ExternalLinkIcon");return r(),a("div",null,[h,e("p",null,[o("nginx是工作中常用的中间件，实际工作中前端、后端项目都由专业人员进行开发、部署，大概率不会部署到到一块，就会使用nginx反向代理，需要查看相关内容可以"),e("a",l,[o("参考"),t(c)]),o("。 对于nginx常用功能涉及到三个方向：")]),e("ol",null,[_,e("li",null,[e("a",p,[o("负载均衡"),t(c)]),o("，Netty也提供了相应"),u,o("，举一反三，在需要负载均衡时就有了参考。")])]),e("div",f,[x,e("p",null,[o("更多均衡策略可以参考"),e("a",m,[o("均衡策略与实现"),t(c)])])]),e("ol",g,[e("li",null,[o("动静分离，在高并发情况下，需要考虑相关内容，可以参考"),e("a",b,[o("周老师的透明多级分流系统"),t(c)])])]),y,e("div",k,[v,e("p",null,[o("更加详细内容请参考 "),e("a",Q,[o("周志明《凤凰架构 服务端缓存》"),t(c)])])]),M,N,R])}const P=d(s,[["render",U],["__file","index.html.vue"]]);export{P as default};

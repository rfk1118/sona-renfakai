import{_ as i}from"./three-hand-2f6a0693.js";import{_ as a,V as r,W as o,Y as e,a1 as t,Z as s,a0 as l,F as c}from"./framework-1bd9c91b.js";const d="/assets/wireshark-nds-query-03c4843a.jpg",h="/assets/tcp-body-40fb61c5.jpg",p="/assets/three-wireshark-01-3122a673.png",_="/assets/three-wireshark-02-1ebe9ece.jpg",m="/assets/three-wireshark-03-55a46107.jpg",g={},u=e("h1",{id:"三次握手",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#三次握手","aria-hidden":"true"},"#"),t(" 三次握手")],-1),f={href:"https://www.wireshark.org/",target:"_blank",rel:"noopener noreferrer"},k=e("h2",{id:"实战",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#实战","aria-hidden":"true"},"#"),t(" 实战")],-1),b=e("div",{style:{"text-align":"center"}},[e("p",null,[e("img",{src:i,alt:"An image"}),t(" 图来自于《TCP IP 协议详解卷一：协议》")])],-1),v={href:"https://github.com/sona0402/netty/blob/master/src/main/java/channelhandlers/TcpDnsClient.java",target:"_blank",rel:"noopener noreferrer"},S=e("code",null,"WireShark",-1),T=e("code",null,"filter",-1),x=e("code",null,"tcp.port == 53",-1),C=l('<div style="text-align:center;"><p><img src="'+d+'" alt="An image"></p></div><p>从图中，看到了<code>SYN ACK SEQ</code>等常用字段，查看 TCP 报文段结构，先查看 TCP 头部信息</p><p><img src="'+h+'" alt="An image"></p><p>TCP 头部有 6 个标记</p><ul><li>URG The urgent pointer is valid 紧急指针</li><li>ACK The acknowledgment number is valid 确认序列号</li><li>PSH The receiver should pass this data to the application as soon as possible 不需要放到连接的缓存，直接上报给应用</li><li>RST Reset the connection 重制链接</li><li>Synchronize sequence numbers to initiate a connection 连接同步初始化序列号</li><li>The sender is finished sending data 发送数据完成时</li></ul><p>info 中的字段信息</p><ul><li>Seq: 包中第一个字节的序号</li><li>Win: 滑动窗口的大小</li><li>Ack: 希望下次收到的 seq 序号</li><li>Len: 传输数据长度(不包括 TCP 头，固定首部 20B)，指用户传输的数据长度</li><li>MSS: 最大消息长度(一般是 1460，也可能不是)，与 MTU(一般 1500，也可能不是)关系: MTU=Ethernet 头+IP 头+TCP/UDP 头+MSS</li></ul><p>客户端发出了一个 SYN 数据段请求，对应图 1 中的 segment1，其实这里发送的数据为客户端序列为 0</p><div style="text-align:center;"><p><img src="'+p+'" alt="An image"></p></div><p>服务端返回一个 SYN ACK 数据段，服务端序列为 0，对客户端确认为 1，这里的 1 是使用客户端给的序列 + 1 得到的，对应图 1 中的 segment2</p><div style="text-align:center;"><p><img src="'+_+'" alt="An image"></p></div><p>客户端给出一个 ACK 数据段请求，Seq=1 Ack = 1，客户端序列是自己增长的，而 Ack 是对服务端序号+1 产生的，对应图 1 中的 segment3</p><div style="text-align:center;"><p><img src="'+m+'" alt="An image"></p></div><h2 id="参考材料" tabindex="-1"><a class="header-anchor" href="#参考材料" aria-hidden="true">#</a> 参考材料</h2>',14),A={href:"https://book.douban.com/subject/1088054/",target:"_blank",rel:"noopener noreferrer"};function P(w,y){const n=c("ExternalLinkIcon");return r(),o("div",null,[u,e("p",null,[t("三次握手是客户端与服务端建立 TCP 连接的前置动作，本文使用 "),e("a",f,[t("Wireshark"),s(n)]),t(" 抓取数据包进行分解查看。")]),k,b,e("p",null,[t("使用"),e("a",v,[t("代码"),s(n)]),t("进行 DNS 查询，并使用"),S,t("进行抓包，抓包使用 "),T,t(" 进行过滤，过滤条件为"),x,t("，过滤后的结果如下图所示:")]),C,e("p",null,[e("a",A,[t("TCP/IP 详解 卷 1：协议"),s(n)])])])}const q=a(g,[["render",P],["__file","tree-shake-hands.html.vue"]]);export{q as default};

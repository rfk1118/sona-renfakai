<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>最小生成树 | 智慧不可赐！</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    <meta name="description" content="因果不可改、智慧不可赐、真法不可说、无缘不能渡！">
    
    <link rel="preload" href="/assets/css/0.styles.7f49ab7e.css" as="style"><link rel="preload" href="/assets/js/app.337e91ef.js" as="script"><link rel="preload" href="/assets/js/2.cc934d9f.js" as="script"><link rel="preload" href="/assets/js/26.acf92556.js" as="script"><link rel="prefetch" href="/assets/js/10.4f230049.js"><link rel="prefetch" href="/assets/js/11.3907fa47.js"><link rel="prefetch" href="/assets/js/12.78791d1b.js"><link rel="prefetch" href="/assets/js/13.31228fa8.js"><link rel="prefetch" href="/assets/js/14.28f3bdb4.js"><link rel="prefetch" href="/assets/js/15.446786de.js"><link rel="prefetch" href="/assets/js/16.7770fe0d.js"><link rel="prefetch" href="/assets/js/17.9b5d218d.js"><link rel="prefetch" href="/assets/js/18.3452767d.js"><link rel="prefetch" href="/assets/js/19.7de700e5.js"><link rel="prefetch" href="/assets/js/20.000cc0f2.js"><link rel="prefetch" href="/assets/js/21.c1617e3f.js"><link rel="prefetch" href="/assets/js/22.7b1bdc0a.js"><link rel="prefetch" href="/assets/js/23.8b6df68e.js"><link rel="prefetch" href="/assets/js/24.b45d118b.js"><link rel="prefetch" href="/assets/js/25.f75a7b2b.js"><link rel="prefetch" href="/assets/js/27.8632e3b7.js"><link rel="prefetch" href="/assets/js/28.65a4f385.js"><link rel="prefetch" href="/assets/js/29.0bb14505.js"><link rel="prefetch" href="/assets/js/3.76282f7d.js"><link rel="prefetch" href="/assets/js/30.72c086e9.js"><link rel="prefetch" href="/assets/js/31.7aa8dfa3.js"><link rel="prefetch" href="/assets/js/32.9ca96558.js"><link rel="prefetch" href="/assets/js/33.ebda435d.js"><link rel="prefetch" href="/assets/js/34.18c5ff6a.js"><link rel="prefetch" href="/assets/js/35.0d83e936.js"><link rel="prefetch" href="/assets/js/36.958c9c4a.js"><link rel="prefetch" href="/assets/js/37.81749598.js"><link rel="prefetch" href="/assets/js/38.03f5e26e.js"><link rel="prefetch" href="/assets/js/39.29d28cbd.js"><link rel="prefetch" href="/assets/js/4.b40ddb79.js"><link rel="prefetch" href="/assets/js/40.e5da55ae.js"><link rel="prefetch" href="/assets/js/41.c94ced0d.js"><link rel="prefetch" href="/assets/js/42.35ce7abc.js"><link rel="prefetch" href="/assets/js/43.668dc9dd.js"><link rel="prefetch" href="/assets/js/44.61b371a7.js"><link rel="prefetch" href="/assets/js/45.748d47d8.js"><link rel="prefetch" href="/assets/js/46.8b794660.js"><link rel="prefetch" href="/assets/js/47.965a5a96.js"><link rel="prefetch" href="/assets/js/48.f1ef9b23.js"><link rel="prefetch" href="/assets/js/49.f88489a6.js"><link rel="prefetch" href="/assets/js/5.4f901f69.js"><link rel="prefetch" href="/assets/js/50.cef8b524.js"><link rel="prefetch" href="/assets/js/51.9d313409.js"><link rel="prefetch" href="/assets/js/52.b9028d78.js"><link rel="prefetch" href="/assets/js/53.37a1df79.js"><link rel="prefetch" href="/assets/js/54.0af71077.js"><link rel="prefetch" href="/assets/js/55.200dd0bd.js"><link rel="prefetch" href="/assets/js/56.ca100e52.js"><link rel="prefetch" href="/assets/js/57.fb080c68.js"><link rel="prefetch" href="/assets/js/58.dda93471.js"><link rel="prefetch" href="/assets/js/59.7091b307.js"><link rel="prefetch" href="/assets/js/6.f5a2c544.js"><link rel="prefetch" href="/assets/js/60.c785e25d.js"><link rel="prefetch" href="/assets/js/61.c0553f1d.js"><link rel="prefetch" href="/assets/js/62.c6828513.js"><link rel="prefetch" href="/assets/js/63.368e7f83.js"><link rel="prefetch" href="/assets/js/64.5742472a.js"><link rel="prefetch" href="/assets/js/65.008bb7c5.js"><link rel="prefetch" href="/assets/js/66.86c9023c.js"><link rel="prefetch" href="/assets/js/67.7629a6a7.js"><link rel="prefetch" href="/assets/js/68.ca685b9e.js"><link rel="prefetch" href="/assets/js/69.a9ee9991.js"><link rel="prefetch" href="/assets/js/7.210a742e.js"><link rel="prefetch" href="/assets/js/70.2d6461f9.js"><link rel="prefetch" href="/assets/js/71.59e4abc5.js"><link rel="prefetch" href="/assets/js/72.551b94ea.js"><link rel="prefetch" href="/assets/js/73.69fd1836.js"><link rel="prefetch" href="/assets/js/74.23bce6cb.js"><link rel="prefetch" href="/assets/js/75.5192c30e.js"><link rel="prefetch" href="/assets/js/76.63b0c48c.js"><link rel="prefetch" href="/assets/js/77.ad676dba.js"><link rel="prefetch" href="/assets/js/78.b6a5c74d.js"><link rel="prefetch" href="/assets/js/79.da28fd1d.js"><link rel="prefetch" href="/assets/js/8.531420eb.js"><link rel="prefetch" href="/assets/js/80.ff7cb1db.js"><link rel="prefetch" href="/assets/js/81.326e2130.js"><link rel="prefetch" href="/assets/js/82.18e47883.js"><link rel="prefetch" href="/assets/js/83.d0de6c41.js"><link rel="prefetch" href="/assets/js/84.5eeb8f0f.js"><link rel="prefetch" href="/assets/js/9.cb7bd98e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7f49ab7e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">智慧不可赐！</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/introduction/about-me.html" class="sidebar-link">作者</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Netty</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>算法</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>排序</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithms/sort/sort.html" class="sidebar-link">概念</a></li><li><a href="/algorithms/sort/bubble-sort.html" class="sidebar-link">冒泡排序</a></li><li><a href="/algorithms/sort/select-sort.html" class="sidebar-link">选择排序</a></li><li><a href="/algorithms/sort/insert-sort.html" class="sidebar-link">插入排序</a></li><li><a href="/algorithms/sort/merge-sort.html" class="sidebar-link">归并排序</a></li><li><a href="/algorithms/sort/quick-sort.html" class="sidebar-link">快速排序</a></li><li><a href="/algorithms/other/Edsger-Dijkstra.html" class="sidebar-link">荷兰国旗</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>数据结构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithms/structure/union-find-structure.html" class="sidebar-link">并查集</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Tree</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithms/tree/binary-tree-concept.html" class="sidebar-link">二叉树</a></li><li><a href="/algorithms/tree/pre-order.html" class="sidebar-link">前序遍历</a></li><li><a href="/algorithms/tree/binary-tree-algs4.html" class="sidebar-link">二叉树-算法4</a></li><li><a href="/algorithms/tree/balanced-search-trees.html" class="sidebar-link">2-3-搜索树</a></li><li><a href="/algorithms/heap/heap.html" class="sidebar-link">Heap</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>图</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithms/graphs/read-source.html" class="sidebar-link">导读</a></li><li><a href="/algorithms/graphs/graph-concept.html" class="sidebar-link">概念</a></li><li><a href="/algorithms/graphs/directed-graph.html" class="sidebar-link">有向图</a></li><li><a href="/algorithms/graphs/graph-search.html" class="sidebar-link">搜索</a></li><li><a href="/algorithms/graphs/minimum-spanning-tree.html" aria-current="page" class="active sidebar-link">最小生成树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithms/graphs/minimum-spanning-tree.html#概念" class="sidebar-link">概念</a></li><li class="sidebar-sub-header"><a href="/algorithms/graphs/minimum-spanning-tree.html#场景" class="sidebar-link">场景</a></li><li class="sidebar-sub-header"><a href="/algorithms/graphs/minimum-spanning-tree.html#mst性质" class="sidebar-link">MST性质</a></li><li class="sidebar-sub-header"><a href="/algorithms/graphs/minimum-spanning-tree.html#常见算法" class="sidebar-link">常见算法</a></li><li class="sidebar-sub-header"><a href="/algorithms/graphs/minimum-spanning-tree.html#prim" class="sidebar-link">Prim</a></li><li class="sidebar-sub-header"><a href="/algorithms/graphs/minimum-spanning-tree.html#kruskal" class="sidebar-link">Kruskal</a></li><li class="sidebar-sub-header"><a href="/algorithms/graphs/minimum-spanning-tree.html#结论" class="sidebar-link">结论</a></li></ul></li><li><a href="/algorithms/graphs/shortest-path-algnorithms.html" class="sidebar-link">最短路径算法</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>Bit</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithms/bit/xor.html" class="sidebar-link">Xor</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithms/other/binary-Search.html" class="sidebar-link">二分查找法</a></li><li><a href="/algorithms/other/Top-down.html" class="sidebar-link">自顶而下</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程语言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="最小生成树">最小生成树</h1> <h2 id="概念">概念</h2> <p>最小（权重）生成树算法从给定节点开始，找到其所有可到达的节点以及以可能的最小权重将节点连接在一起的一组关系。它从任何已访问节点遍历到下一个具有最低权重的未访问节点，从而避免循环。</p> <p>第一个已知的最小权重生成树算法是由捷克科学家<code>Otakar Borůvka</code>于1926年开发的。<code>Prim</code>算法于1957年发明，是最简单和最著名的算法。</p> <p><code>Prim</code>的算法类似于<code>Dijkstra</code>的最短路径算法，但不是最小化以每个关系结束的路径的总长度，而是分别最小化每个关系的长度。与 <code>Dijkstra</code> 算法不同，它可以存在负权重关系。</p> <h2 id="场景">场景</h2> <ul><li>n个城市建立通信网问题</li></ul> <h2 id="mst性质">MST性质</h2> <ul><li><p>已经落在生成树上的顶点集合：U</p></li> <li><p>尚未落在子生成树上的顶点集合：T = V - U</p></li> <li><p>从U的顶点和T中顶点的边中选取权值最小的边</p></li></ul> <div class="spinner" style="background:rgb(66, 185, 131);" data-v-1bbcb91a></div><p>设 N = (V,E) 是一个连网，U是顶点集合V的非空子集。若边(u,v)是一条具有最小权值的边，其中u <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> U , v <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span>  T ，则必存在一棵包含(u,v)的最小生成树。</p> <p><img src="/assets/img/mst.b54a62bb.png" alt="An image"></p> <ul><li>N = <code>(V,{E})</code></li> <li>v = <code>{v1,v2,v3,v4,v5,v6}</code></li> <li>E = <code>{(v1,v2),(v1,v3),(v1,v4),(v2,v3),(v2,v5),(v3,v4),(v3,v5),(v3,v6),(v4,v6),(v5,v6)}</code></li> <li>U = <code>(v1)</code></li></ul> <h2 id="常见算法">常见算法</h2> <ul><li><a href="/algorithms/graphs/minimum-spanning-tree.html#Prim">Prim’s algorithm</a></li> <li><a href="/algorithms/graphs/minimum-spanning-tree.html#Kruskal">Kruskal’s algorithm</a></li></ul> <h2 id="prim">Prim</h2> <ul><li>设N =(V,E)是连通网，TE是N上最小生成树中边的集合</li> <li>初始化U={<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">u_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">u</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>}，（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">u_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">u</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span>  V）TE={}</li> <li>在所有u <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> U,v <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> V - U的边（u,v) <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mrel">∈</span></span></span></span> E中找到一条代价最小的边(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">u_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">u</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)</li> <li>将(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">u_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">u</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>)加入集合TE，同时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">v_0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>加入U。</li> <li>重复上述操作直至U=V为止，则T=(V,TE)为N的最小生成树</li></ul> <h3 id="prim代码"><a href="https://algs4.cs.princeton.edu/43mst/PrimMST.java.html" target="_blank" rel="noopener noreferrer">Prim代码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <ul><li>从每个顶点都开始迭代一次，这样可以处理深林问题</li> <li>处理过<code>marked</code>的数据不在处理</li> <li><code>if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);</code>回溯修正最小顶点问题</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrimMST</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">double</span> FLOATING_POINT_EPSILON <span class="token operator">=</span> <span class="token number">1E-12</span><span class="token punctuation">;</span>
  <span class="token comment">// 从树中到非树的顶点</span>
  <span class="token keyword">private</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edgeTo<span class="token punctuation">;</span>        <span class="token comment">// edgeTo[v] = shortest edge from tree vertex to non-tree vertex</span>
  <span class="token comment">// 边的权重保存</span>
  <span class="token keyword">private</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> distTo<span class="token punctuation">;</span>      <span class="token comment">// distTo[v] = weight of shortest such edge</span>
  <span class="token comment">// 是否已经处理过</span>
  <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span>     <span class="token comment">// marked[v] = true if v on tree, false otherwise</span>
  <span class="token keyword">private</span> <span class="token class-name">IndexMinPQ</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> pq<span class="token punctuation">;</span>

  <span class="token comment">/**
  * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
  * @param G the edge-weighted graph
  */</span>
  <span class="token keyword">public</span> <span class="token class-name">PrimMST</span><span class="token punctuation">(</span><span class="token class-name">EdgeWeightedGraph</span> <span class="token class-name">G</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 初始化数据</span>
      edgeTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      distTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexMinPQ</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span>
          distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span>POSITIVE_INFINITY<span class="token punctuation">;</span>
      <span class="token comment">// 没有访问过进行处理，这里主要处理森林问题</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token comment">// run from each vertex to find</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// minimum spanning forest</span>

      <span class="token comment">// check optimality conditions</span>
      <span class="token keyword">assert</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

    <span class="token comment">// run Prim's algorithm in graph G, starting from vertex s</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token class-name">EdgeWeightedGraph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 从这个节点开始</span>
      distTo<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
      pq<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> distTo<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 队列不为空</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 获取最小的顶点</span>
          <span class="token keyword">int</span> v <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">delMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 处理图中最小顶点</span>
          <span class="token function">scan</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

    <span class="token comment">// scan vertex v</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">scan</span><span class="token punctuation">(</span><span class="token class-name">EdgeWeightedGraph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 标记顶点已经处理过</span>
      marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> e <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 找到边的另外一个顶点</span>
          <span class="token keyword">int</span> w <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">other</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 如果已经处理过跳过</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>         <span class="token comment">// v-w is obsolete edge</span>
          <span class="token comment">// 修正边的权重</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token comment">// 修正权重</span>
              distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token comment">// w 到 e 修正</span>
              edgeTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
              <span class="token comment">// 动态修正最小边</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span> pq<span class="token punctuation">.</span><span class="token function">decreaseKey</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token comment">// 否则插入顶点和权重</span>
              <span class="token keyword">else</span>                pq<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="kruskal">Kruskal</h2> <ul><li>设连通网 N =(V,E)，令最小生成树初始状态为只有n个顶点而无边的非连通图T=(V,{})，每个顶点自成一个连通分量。</li> <li>在E中选择代价最小的边，若该边依附的顶点骡子T中不同的连通分量上（不能成环)，则将此边加入到T中，否则舍去此边，选取下一条代价最小的边。</li> <li>以此类推，直到T中所有顶点都在同一连通分量上为止。</li></ul> <h3 id="kruskal实现">Kruskal实现</h3> <ul><li>优先级队列处理权重问题</li> <li><code>union-find</code>处理循环问题</li> <li>队列存储边</li></ul> <h3 id="kruskal代码"><a href="https://algs4.cs.princeton.edu/43mst/KruskalMST.java.html" target="_blank" rel="noopener noreferrer">Kruskal代码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>这里使用了以下性质</p> <ul><li>使用选择边为基础进行连接，每次都选择最小的边，可以使用数组排序，也可以使用小根堆</li> <li>使用<a href="/algorithms/structure/union-find-structure.html">并查集</a>，保证集合里面没有循环</li> <li>如果边数等于顶点数量-1，这时候已经是最小生成树，如果在加一条边必然后有循环</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KruskalMST</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">double</span> FLOATING_POINT_EPSILON <span class="token operator">=</span> <span class="token number">1E-12</span><span class="token punctuation">;</span>

  <span class="token comment">// 最小生成树的权重</span>
  <span class="token keyword">private</span> <span class="token keyword">double</span> weight<span class="token punctuation">;</span>                        <span class="token comment">// weight of MST</span>
  <span class="token comment">// 保存边</span>
  <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> mst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// edges in MST</span>

  <span class="token comment">/**
    * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
    * @param G the edge-weighted graph
    */</span>
  <span class="token keyword">public</span> <span class="token class-name">KruskalMST</span><span class="token punctuation">(</span><span class="token class-name">EdgeWeightedGraph</span> <span class="token class-name">G</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

      <span class="token comment">// create array of edges, sorted by weight</span>
      <span class="token comment">// 所有边的数组</span>
      <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>E</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> e<span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">edges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 保存边的数组</span>
          edges<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 进行排序，从小到大，也可以使用小根堆</span>
      <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// 并查集</span>
      <span class="token comment">// run greedy algorithm</span>
      <span class="token class-name">UF</span> uf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">UF</span><span class="token punctuation">(</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 迭代所有的数据，并且边小于顶点-1，在加一条必然有环</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">G<span class="token punctuation">.</span>E</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> mst<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token class-name">Edge</span> e <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
          <span class="token comment">// 顶点1</span>
          <span class="token keyword">int</span> v <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">either</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 顶点2</span>
          <span class="token keyword">int</span> w <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">other</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token comment">// 如果两个顶点不在一个集合里</span>
          <span class="token comment">// v-w does not create a cycle</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">!=</span> uf<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token comment">// 进行合并</span>
              uf<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// merge v and w components</span>
              <span class="token comment">// 放到队列</span>
              mst<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// add edge e to mst</span>
              weight <span class="token operator">+=</span> e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// check optimality conditions</span>
      <span class="token keyword">assert</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="结论">结论</h2> <table><thead><tr><th>算法名</th> <th>普里姆算法</th> <th>克鲁斯卡尔</th></tr></thead> <tbody><tr><td>算法思想</td> <td>选择点</td> <td>选择边</td></tr> <tr><td>算法思想</td> <td>O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">n</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>) n为顶点数</td> <td>O(eloge) e为边数</td></tr> <tr><td>适用范围</td> <td>稠密图</td> <td>稀疏图</td></tr></tbody></table></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/algorithms/graphs/graph-search.html" class="prev">
        搜索
      </a></span> <span class="next"><a href="/algorithms/graphs/shortest-path-algnorithms.html">
        最短路径算法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><div></div><!----></div></div>
    <script src="/assets/js/app.337e91ef.js" defer></script><script src="/assets/js/2.cc934d9f.js" defer></script><script src="/assets/js/26.acf92556.js" defer></script>
  </body>
</html>
